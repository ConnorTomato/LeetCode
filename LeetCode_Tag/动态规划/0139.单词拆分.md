#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

> - `DP`
> - 执行用时：8 ms, 在所有 Java 提交中击败了54.84%的用户

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        // dp[i] 以 i - 1 结尾的字符串是否可被 wordDict 拆分
        boolean[] dp = new boolean[len + 1];
        dp[0] = true;
        for(int i = 1; i <= len; i++){
            for(int j = 0; j < i; j++){
                if(dp[j] && wordDict.contains(s.substring(j, i))){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[len];
    }
}
```

> - `Trie`
> - 执行用时：2 ms, 在所有 Java 提交中击败了92.21%的用户

```java
class Solution {
    class TrieNode {
        private boolean isEnd;

        private TrieNode[] next;

        public TrieNode() {
            this.isEnd = false;
            this.next = new TrieNode[26];
        }
    }

    private TrieNode root = new TrieNode();

    private boolean[] failMemory;

    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        failMemory = new boolean[len];
        for (String str : wordDict) {
            insert(str);
        }
        return dfs(s, 0);
    }

    private boolean dfs(String s, int index) {
        if (index == s.length()) {
            return true;
        }
        if (failMemory[index]) {
            return false;
        }

        TrieNode node = root;
        for (int i = index; i < s.length(); i++) {
            char c = s.charAt(i);
            if (node.next[c - 'a'] == null) {
                failMemory[index] = true;
                return false;
            }
            node = node.next[c - 'a'];
            if (node.isEnd && dfs(s, i + 1)) {
                return true;
            }
        }
        failMemory[index] = true;
        return false;
    }

    private void insert(String s) {
        TrieNode node = root;
        for (char c : s.toCharArray()) {
            if (node.next[c - 'a'] == null) {
                node.next[c - 'a'] = new TrieNode();
            }
            node = node.next[c - 'a'];
        }
        node.isEnd = true;
    }
}
```

