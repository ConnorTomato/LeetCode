#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

> - 执行用时：1 ms, 在所有 Java 提交中击败了65.20%的用户

```java
class Solution {
    // 记录全局最小路径和
    private int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if(root == null){
            return 0;
        }
        dfs(root);
        return max;
    }
    // 返回经过root的单边分支最大和， 即Math.max(root, root+left, root+right)
    private int dfs(TreeNode root){
        if(root == null){
            return 0;
        }
        //计算左边分支最大值，左边分支如果为负数还不如不选择
        int left = Math.max(0, dfs(root.left));
        int right = Math.max(0, dfs(root.right));
        //left->root->right 作为路径与已经计算过历史最大值做比较
        max = Math.max(max, root.val + left + right);
        // 返回经过root的单边最大分支给当前root的父节点计算使用
        return root.val + Math.max(left, right);
    }
}
```

